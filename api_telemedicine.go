/*
LifePlus Healthcare Platform API

# LifePlus Healthcare Platform API  Enterprise-grade healthcare platform API for partner integration and third-party developers.  ## Platform Capabilities  ### Healthcare Services - **Telemedicine**: Video consultations with licensed doctors - **Appointments**: In-person doctor appointments at hospitals - **Diagnostics**: Lab tests and diagnostic services - **Home Sample Collection**: At-home diagnostic sample collection - **Ambulance**: Emergency ambulance booking - **Home Care**: Nursing and home care services  ### E-Commerce - **Pharmacy**: Medicine ordering and delivery - **Lifestyle Products**: Health supplements, medical devices - **Shopping Cart**: Multi-vendor cart management - **Order Fulfillment**: Complete order lifecycle management  ### Insurance & Packages - **Health Packages**: Subscription-based healthcare bundles - **Health Cards**: Membership cards with benefits - **Insurance Policies**: Policy browsing and purchase - **Claims Management**: Insurance claim processing  ## Architecture Overview  This API follows **domain-driven design** with clear separation of concerns:  ### Microservices Layer - **Auth Service**: JWT-based authentication and authorization - **User Service**: User profiles and beneficiary management - **Order Service**: Unified order processing for all order types - **Healthcare Service**: Medical services orchestration - **Product Service**: Catalog and inventory management - **Payment Service**: Payment gateway integration - **Notification Service**: SMS, email, push notifications  ### Service Layer (Business Logic) - Video call session management (Agora integration) - Doctor availability and slot booking - Package benefit calculation and tracking - Promo code validation and discount application - Corporate package enrollment  ### Integration Layer (Packages/SDKs) - **Go SDK**: High-performance SDK for Go applications - **PHP Laravel SDK**: Native Laravel package for PHP apps - **TypeScript SDK**: Modern TypeScript client with types  ### External Plugins - **SSL Commerz**: Payment gateway for Bangladesh - **Agora.io**: Real-time video/audio communication - **Firebase**: Push notifications - **AWS S3**: File storage  ## API Standards  ### REST Principles - **Resource-Based URIs**: Use plural nouns (`/orders`, `/users`, `/appointments`) - **HTTP Verbs**: GET (read), POST (create), PATCH (update), DELETE (remove) - **Stateless**: Each request contains all necessary information - **HATEOAS**: Include links to related resources when applicable  ### Naming Conventions - ✅ **Correct**: `/orders`, `/appointments`, `/products` - ❌ **Incorrect**: `/product-orders`, `/get-orders`, `/createAppointment`  ### Response Format All responses follow a consistent structure: ```json {   \"success\": true,   \"message\": \"Operation completed successfully\",   \"data\": { ... },   \"meta\": { \"pagination\": {...} } } ```  ### Error Handling Errors follow RFC 7807 Problem Details: ```json {   \"success\": false,   \"message\": \"Validation failed\",   \"code\": 422,   \"errors\": {     \"email\": [\"The email field is required\"],     \"phone\": [\"The phone format is invalid\"]   } } ```  ### Pagination List endpoints support consistent pagination: - `page`: Current page number (default: 1) - `per_page`: Items per page (default: 15, max: 100) - `sort`: Field to sort by (default: created_at) - `order`: Sort direction (asc/desc, default: desc) - `q`: Search query  ### Authentication Most endpoints require JWT Bearer authentication: ``` Authorization: Bearer <your_jwt_token> ```  Obtain a token by calling `POST /sessions` with valid credentials.  ### Rate Limiting - **Standard**: 60 requests/minute per IP - **Authenticated**: 120 requests/minute per user - **Partner API**: Custom limits based on agreement  ### Versioning - API version is in the URL: `/api/v1` - Breaking changes will result in new version: `/api/v2` - Old versions supported for 12 months after deprecation notice  ## SDK Usage  ### Go SDK ```go import \"github.com/LifeplusBangladesh/lifeplus-go-sdk\"  client := lifeplus.NewClient(\"your-api-key\") products, err := client.Products.List(context.Background(), &lifeplus.ProductListOptions{     Page: 1,     PerPage: 20, }) ```  ### PHP Laravel SDK ```php use LifePlus\\SDK\\LifePlusClient;  $client = new LifePlusClient(env('LIFEPLUS_API_KEY')); $products = $client->products()->list(['per_page' => 20]); ```  ### TypeScript SDK ```typescript import { LifePlusClient } from '@lifeplus/sdk';  const client = new LifePlusClient({ apiKey: 'your-api-key' }); const products = await client.products.list({ perPage: 20 }); ``` 

API version: 2.0.0
Contact: mamun@lifeplusbd.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lifeplusapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type TelemedicineAPI interface {

	/*
	GetVideoCallHistory Get video call history

	Retrieve video call history for a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetVideoCallHistoryRequest
	*/
	GetVideoCallHistory(ctx context.Context) ApiGetVideoCallHistoryRequest

	// GetVideoCallHistoryExecute executes the request
	//  @return []VideoCallHistory
	GetVideoCallHistoryExecute(r ApiGetVideoCallHistoryRequest) ([]VideoCallHistory, *http.Response, error)

	/*
	RequestVideoCall Request a video call

	Initiate a video call request with a doctor

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestVideoCallRequest
	*/
	RequestVideoCall(ctx context.Context) ApiRequestVideoCallRequest

	// RequestVideoCallExecute executes the request
	//  @return VideoCallHistory
	RequestVideoCallExecute(r ApiRequestVideoCallRequest) (*VideoCallHistory, *http.Response, error)

	/*
	TelemedicineHistoryGet Get user telemedicine history

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTelemedicineHistoryGetRequest
	*/
	TelemedicineHistoryGet(ctx context.Context) ApiTelemedicineHistoryGetRequest

	// TelemedicineHistoryGetExecute executes the request
	TelemedicineHistoryGetExecute(r ApiTelemedicineHistoryGetRequest) (*http.Response, error)

	/*
	TelemedicineSlotsPost Reserve doctor slot

	Create a new slot reservation (POST to collection creates a resource)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTelemedicineSlotsPostRequest
	*/
	TelemedicineSlotsPost(ctx context.Context) ApiTelemedicineSlotsPostRequest

	// TelemedicineSlotsPostExecute executes the request
	TelemedicineSlotsPostExecute(r ApiTelemedicineSlotsPostRequest) (*http.Response, error)

	/*
	UploadVideoCallPrescription Upload prescription for video call

	Upload prescription image for a video call session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Video call room ID
	@return ApiUploadVideoCallPrescriptionRequest
	*/
	UploadVideoCallPrescription(ctx context.Context, id int32) ApiUploadVideoCallPrescriptionRequest

	// UploadVideoCallPrescriptionExecute executes the request
	//  @return SuccessResponse
	UploadVideoCallPrescriptionExecute(r ApiUploadVideoCallPrescriptionRequest) (*SuccessResponse, *http.Response, error)

	/*
	VideoCallsIdTokenDelete Revoke video call token

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiVideoCallsIdTokenDeleteRequest
	*/
	VideoCallsIdTokenDelete(ctx context.Context, id int32) ApiVideoCallsIdTokenDeleteRequest

	// VideoCallsIdTokenDeleteExecute executes the request
	VideoCallsIdTokenDeleteExecute(r ApiVideoCallsIdTokenDeleteRequest) (*http.Response, error)

	/*
	VideoCallsIdTokenGet Get video call token

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiVideoCallsIdTokenGetRequest
	*/
	VideoCallsIdTokenGet(ctx context.Context, id int32) ApiVideoCallsIdTokenGetRequest

	// VideoCallsIdTokenGetExecute executes the request
	VideoCallsIdTokenGetExecute(r ApiVideoCallsIdTokenGetRequest) (*http.Response, error)

	/*
	VideoCallsIdTokenPost Generate video call token

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiVideoCallsIdTokenPostRequest
	*/
	VideoCallsIdTokenPost(ctx context.Context, id int32) ApiVideoCallsIdTokenPostRequest

	// VideoCallsIdTokenPostExecute executes the request
	VideoCallsIdTokenPostExecute(r ApiVideoCallsIdTokenPostRequest) (*http.Response, error)
}

// TelemedicineAPIService TelemedicineAPI service
type TelemedicineAPIService service

type ApiGetVideoCallHistoryRequest struct {
	ctx context.Context
	ApiService TelemedicineAPI
	userId *int32
	page *int32
	perPage *int32
}

func (r ApiGetVideoCallHistoryRequest) UserId(userId int32) ApiGetVideoCallHistoryRequest {
	r.userId = &userId
	return r
}

// Page number for pagination
func (r ApiGetVideoCallHistoryRequest) Page(page int32) ApiGetVideoCallHistoryRequest {
	r.page = &page
	return r
}

// Number of items per page
func (r ApiGetVideoCallHistoryRequest) PerPage(perPage int32) ApiGetVideoCallHistoryRequest {
	r.perPage = &perPage
	return r
}

func (r ApiGetVideoCallHistoryRequest) Execute() ([]VideoCallHistory, *http.Response, error) {
	return r.ApiService.GetVideoCallHistoryExecute(r)
}

/*
GetVideoCallHistory Get video call history

Retrieve video call history for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVideoCallHistoryRequest
*/
func (a *TelemedicineAPIService) GetVideoCallHistory(ctx context.Context) ApiGetVideoCallHistoryRequest {
	return ApiGetVideoCallHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VideoCallHistory
func (a *TelemedicineAPIService) GetVideoCallHistoryExecute(r ApiGetVideoCallHistoryRequest) ([]VideoCallHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VideoCallHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TelemedicineAPIService.GetVideoCallHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video-calls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "", "")
	} else {
		var defaultValue int32 = 10
		r.perPage = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestVideoCallRequest struct {
	ctx context.Context
	ApiService TelemedicineAPI
	dId *int32
	callType *string
	getVideoCallToken *int32
	channelName *string
	myself *int32
	pName *string
	pPhone *string
	pAge *int32
	pGender *string
	dName *string
	bookSlotDate *string
	bookSlotValue *string
	patientPrescriptions []*os.File
}

// Doctor ID
func (r ApiRequestVideoCallRequest) DId(dId int32) ApiRequestVideoCallRequest {
	r.dId = &dId
	return r
}

func (r ApiRequestVideoCallRequest) CallType(callType string) ApiRequestVideoCallRequest {
	r.callType = &callType
	return r
}

func (r ApiRequestVideoCallRequest) GetVideoCallToken(getVideoCallToken int32) ApiRequestVideoCallRequest {
	r.getVideoCallToken = &getVideoCallToken
	return r
}

func (r ApiRequestVideoCallRequest) ChannelName(channelName string) ApiRequestVideoCallRequest {
	r.channelName = &channelName
	return r
}

// 1&#x3D;myself, 0&#x3D;others
func (r ApiRequestVideoCallRequest) Myself(myself int32) ApiRequestVideoCallRequest {
	r.myself = &myself
	return r
}

// Patient name
func (r ApiRequestVideoCallRequest) PName(pName string) ApiRequestVideoCallRequest {
	r.pName = &pName
	return r
}

func (r ApiRequestVideoCallRequest) PPhone(pPhone string) ApiRequestVideoCallRequest {
	r.pPhone = &pPhone
	return r
}

func (r ApiRequestVideoCallRequest) PAge(pAge int32) ApiRequestVideoCallRequest {
	r.pAge = &pAge
	return r
}

func (r ApiRequestVideoCallRequest) PGender(pGender string) ApiRequestVideoCallRequest {
	r.pGender = &pGender
	return r
}

func (r ApiRequestVideoCallRequest) DName(dName string) ApiRequestVideoCallRequest {
	r.dName = &dName
	return r
}

func (r ApiRequestVideoCallRequest) BookSlotDate(bookSlotDate string) ApiRequestVideoCallRequest {
	r.bookSlotDate = &bookSlotDate
	return r
}

func (r ApiRequestVideoCallRequest) BookSlotValue(bookSlotValue string) ApiRequestVideoCallRequest {
	r.bookSlotValue = &bookSlotValue
	return r
}

func (r ApiRequestVideoCallRequest) PatientPrescriptions(patientPrescriptions []*os.File) ApiRequestVideoCallRequest {
	r.patientPrescriptions = patientPrescriptions
	return r
}

func (r ApiRequestVideoCallRequest) Execute() (*VideoCallHistory, *http.Response, error) {
	return r.ApiService.RequestVideoCallExecute(r)
}

/*
RequestVideoCall Request a video call

Initiate a video call request with a doctor

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRequestVideoCallRequest
*/
func (a *TelemedicineAPIService) RequestVideoCall(ctx context.Context) ApiRequestVideoCallRequest {
	return ApiRequestVideoCallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VideoCallHistory
func (a *TelemedicineAPIService) RequestVideoCallExecute(r ApiRequestVideoCallRequest) (*VideoCallHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VideoCallHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TelemedicineAPIService.RequestVideoCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video-calls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dId == nil {
		return localVarReturnValue, nil, reportError("dId is required and must be specified")
	}
	if r.callType == nil {
		return localVarReturnValue, nil, reportError("callType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.getVideoCallToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "get_video_call_token", r.getVideoCallToken, "", "")
	}
	if r.channelName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "channel_name", r.channelName, "", "")
	}
	if r.myself != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "myself", r.myself, "", "")
	}
	if r.pName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "p_name", r.pName, "", "")
	}
	if r.pPhone != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "p_phone", r.pPhone, "", "")
	}
	if r.pAge != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "p_age", r.pAge, "", "")
	}
	if r.pGender != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "p_gender", r.pGender, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "d_id", r.dId, "", "")
	if r.dName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "d_name", r.dName, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "call_type", r.callType, "", "")
	if r.bookSlotDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "book_slot_date", r.bookSlotDate, "", "")
	}
	if r.bookSlotValue != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "book_slot_value", r.bookSlotValue, "", "")
	}
	var patientPrescriptionsLocalVarFormFileName string
	var patientPrescriptionsLocalVarFileName     string
	var patientPrescriptionsLocalVarFileBytes    []byte

	patientPrescriptionsLocalVarFormFileName = "patient_prescriptions"
	patientPrescriptionsLocalVarFile := r.patientPrescriptions

	if patientPrescriptionsLocalVarFile != nil {
		// loop through the array to prepare multiple files upload
		for _, patientPrescriptionsLocalVarFileValue := range patientPrescriptionsLocalVarFile {
			fbs, _ := io.ReadAll(patientPrescriptionsLocalVarFileValue)

			patientPrescriptionsLocalVarFileBytes = fbs
			patientPrescriptionsLocalVarFileName = patientPrescriptionsLocalVarFileValue.Name()
			patientPrescriptionsLocalVarFileValue.Close()
			formFiles = append(formFiles, formFile{fileBytes: patientPrescriptionsLocalVarFileBytes, fileName: patientPrescriptionsLocalVarFileName, formFileName: patientPrescriptionsLocalVarFormFileName})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTelemedicineHistoryGetRequest struct {
	ctx context.Context
	ApiService TelemedicineAPI
	userId *int32
}

func (r ApiTelemedicineHistoryGetRequest) UserId(userId int32) ApiTelemedicineHistoryGetRequest {
	r.userId = &userId
	return r
}

func (r ApiTelemedicineHistoryGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.TelemedicineHistoryGetExecute(r)
}

/*
TelemedicineHistoryGet Get user telemedicine history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTelemedicineHistoryGetRequest
*/
func (a *TelemedicineAPIService) TelemedicineHistoryGet(ctx context.Context) ApiTelemedicineHistoryGetRequest {
	return ApiTelemedicineHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TelemedicineAPIService) TelemedicineHistoryGetExecute(r ApiTelemedicineHistoryGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TelemedicineAPIService.TelemedicineHistoryGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/telemedicine/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return nil, reportError("userId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTelemedicineSlotsPostRequest struct {
	ctx context.Context
	ApiService TelemedicineAPI
	telemedicineSlotReservation *TelemedicineSlotReservation
}

func (r ApiTelemedicineSlotsPostRequest) TelemedicineSlotReservation(telemedicineSlotReservation TelemedicineSlotReservation) ApiTelemedicineSlotsPostRequest {
	r.telemedicineSlotReservation = &telemedicineSlotReservation
	return r
}

func (r ApiTelemedicineSlotsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.TelemedicineSlotsPostExecute(r)
}

/*
TelemedicineSlotsPost Reserve doctor slot

Create a new slot reservation (POST to collection creates a resource)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTelemedicineSlotsPostRequest
*/
func (a *TelemedicineAPIService) TelemedicineSlotsPost(ctx context.Context) ApiTelemedicineSlotsPostRequest {
	return ApiTelemedicineSlotsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TelemedicineAPIService) TelemedicineSlotsPostExecute(r ApiTelemedicineSlotsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TelemedicineAPIService.TelemedicineSlotsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/telemedicine/slots"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.telemedicineSlotReservation == nil {
		return nil, reportError("telemedicineSlotReservation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.telemedicineSlotReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUploadVideoCallPrescriptionRequest struct {
	ctx context.Context
	ApiService TelemedicineAPI
	image *os.File
	id int32
	roomId *int32
}

func (r ApiUploadVideoCallPrescriptionRequest) Image(image *os.File) ApiUploadVideoCallPrescriptionRequest {
	r.image = image
	return r
}

// Video call room id (if required by backend)
func (r ApiUploadVideoCallPrescriptionRequest) RoomId(roomId int32) ApiUploadVideoCallPrescriptionRequest {
	r.roomId = &roomId
	return r
}

func (r ApiUploadVideoCallPrescriptionRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.UploadVideoCallPrescriptionExecute(r)
}

/*
UploadVideoCallPrescription Upload prescription for video call

Upload prescription image for a video call session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Video call room ID
 @return ApiUploadVideoCallPrescriptionRequest
*/
func (a *TelemedicineAPIService) UploadVideoCallPrescription(ctx context.Context, id int32) ApiUploadVideoCallPrescriptionRequest {
	return ApiUploadVideoCallPrescriptionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *TelemedicineAPIService) UploadVideoCallPrescriptionExecute(r ApiUploadVideoCallPrescriptionRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TelemedicineAPIService.UploadVideoCallPrescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video-calls/{id}/prescriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.image == nil {
		return localVarReturnValue, nil, reportError("image is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "room_id", r.roomId, "", "")
	}
	var imageLocalVarFormFileName string
	var imageLocalVarFileName     string
	var imageLocalVarFileBytes    []byte

	imageLocalVarFormFileName = "image"
	imageLocalVarFile := r.image

	if imageLocalVarFile != nil {
		fbs, _ := io.ReadAll(imageLocalVarFile)

		imageLocalVarFileBytes = fbs
		imageLocalVarFileName = imageLocalVarFile.Name()
		imageLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: imageLocalVarFileBytes, fileName: imageLocalVarFileName, formFileName: imageLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVideoCallsIdTokenDeleteRequest struct {
	ctx context.Context
	ApiService TelemedicineAPI
	id int32
}

func (r ApiVideoCallsIdTokenDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VideoCallsIdTokenDeleteExecute(r)
}

/*
VideoCallsIdTokenDelete Revoke video call token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiVideoCallsIdTokenDeleteRequest
*/
func (a *TelemedicineAPIService) VideoCallsIdTokenDelete(ctx context.Context, id int32) ApiVideoCallsIdTokenDeleteRequest {
	return ApiVideoCallsIdTokenDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TelemedicineAPIService) VideoCallsIdTokenDeleteExecute(r ApiVideoCallsIdTokenDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TelemedicineAPIService.VideoCallsIdTokenDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video-calls/{id}/token"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVideoCallsIdTokenGetRequest struct {
	ctx context.Context
	ApiService TelemedicineAPI
	id int32
}

func (r ApiVideoCallsIdTokenGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VideoCallsIdTokenGetExecute(r)
}

/*
VideoCallsIdTokenGet Get video call token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiVideoCallsIdTokenGetRequest
*/
func (a *TelemedicineAPIService) VideoCallsIdTokenGet(ctx context.Context, id int32) ApiVideoCallsIdTokenGetRequest {
	return ApiVideoCallsIdTokenGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TelemedicineAPIService) VideoCallsIdTokenGetExecute(r ApiVideoCallsIdTokenGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TelemedicineAPIService.VideoCallsIdTokenGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video-calls/{id}/token"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVideoCallsIdTokenPostRequest struct {
	ctx context.Context
	ApiService TelemedicineAPI
	id int32
}

func (r ApiVideoCallsIdTokenPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VideoCallsIdTokenPostExecute(r)
}

/*
VideoCallsIdTokenPost Generate video call token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiVideoCallsIdTokenPostRequest
*/
func (a *TelemedicineAPIService) VideoCallsIdTokenPost(ctx context.Context, id int32) ApiVideoCallsIdTokenPostRequest {
	return ApiVideoCallsIdTokenPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TelemedicineAPIService) VideoCallsIdTokenPostExecute(r ApiVideoCallsIdTokenPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TelemedicineAPIService.VideoCallsIdTokenPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video-calls/{id}/token"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
